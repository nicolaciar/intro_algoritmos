
Diremos que una **función** relaciona los elementos de un conjunto, llamado dominio, elementos de otro conjunto, llamado codominio. La notación:

$$
f:A\to B
$$
indica que $f$ es una función con dominio $A$ y codominio $B$.

Para denotar a la aplicación de una función utilizaremos la siguiente notación:

$$
\verb|f.a ≐ <expresion que depende de x>|
$$
donde $\verb|f|$ es el nombre de la función y $\verb|x|$ es la variable independiente.


## Cómo definir funciones

Generalmente las funciones son definidas usando expresiones, como en los siguientes ejemplos:

$$
\begin{align*}
&\verb|f.x ≐ 2x^2+4|\\
&\verb|g.y ≐ 3|\\
&\verb|h.z ≐ 7z|
\end{align*}
$$

También puede tener más de un argumento:

$$
\verb|f.x.y ≐ x + y|
$$

## Tipado de funciones

Además de dar una fórmula para definir una función, pediremos el **tipo** de la misma declarado explícitamente.

Como ya vimos, las funciones toman uno o más argumentos, todos ellos con un tipo asociado. Así, la función $\verb|f|$ definida por la siguiente fórmula:

$$\verb|f.x ≐ x + 4|$$
toma un argumento de tipo $\verb|Num|$.

A su vez, las funciones devuelven un valor que también tiene su tipo. En el caso de la función $\verb|f|$ definida anteriormente, el valor que esta función devuelve al ser evaluada es de tipo $\verb|Num|$.

Para capturar esta característica de las funciones, en la declaración de su tipo utilizaremos el símbolo $\to$. Así, el tipo de $\verb|f|$ se declarará de la siguiente forma:

$$
\verb|f :: Num|\to\verb|Num|
$$

Otro ejemplo, tomemos la función $\verb|g|$ definida así:

$$
\verb|g.x.y ≐ 3x - x*y > 0|
$$
Su tipo se declara de la siguiente forma:

$$
\verb|g :: Num|\ \to\verb|Num| \to \verb|Bool|
$$

## Expresiones y funciones

Una vez definida alguna función, como por ejemplo:

$$\begin{align*}
&\verb|duplica|::  Num\to Num\\ 
&\verb|duplica.x ≐ 2 * x|
\end{align*}$$
Se puede usar en expresiones compuestas cómo:

$$
\verb|duplica.(4+2)|+\verb|multiplicar.9.7|=75
$$
Del mismo modo, los argumentos de una función pueden ser cualquier expresión del tipo adecuado.


## Definición de funciones por casos

Un mecanismo muy útil para definir a este tipo de funciones es el análisis por casos. Cuando se usa esta construcción, el valor que tomará la función dependerá de que ciertas expresiones booleanas sean ciertas o no.

Una **definición por casos** de una función tendrá la siguiente forma general:

$$\begin{align*}
\verb|f.x ≐ | (\quad &B_0\to f_0\\
\square\quad &B_1\to f_1\\
 &\vdots\\
 \square\quad &B_n\to f_n\\
 )\quad
 \end{align*}$$
 donde los $B_i$ son expresiones de tipo booleano, llamadas **guardas** y las $f_i$ son expresiones del mismo tipo que el resultado de $f$.

Para un argumento dado el valor de la función se corresponde con la expresión *cuya guarda es verdadera para ese argumento*.

Para que esto tenga sentido es requerimiento para que una función por casos esté bien definida que las guardas sean *disjuntas* entre sí, esto quiere decir que no puede ocurrir que un argumento haga verdadera dos o más guardas al mismo tiempo.

**Ejemplo**

$$\begin{align*}
\verb|maximo.x.y|&::Nat\to Nat\to Nat\\
\verb|maximo.x.y|&≐(\,\,x\leq y \to y\\
&\quad\square\, \,x>y\to x\\&\quad\,\,)
\end{align*}$$

## Pattern matching

